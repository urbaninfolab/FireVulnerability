isochrone@proj4string@projargs <- hosp_supply.sp@proj4string@projargs
# Plots fire station points over catchment areas and takes name of subzone
catchment_matrix[,i] <- over(hosp_supply.sp,
isochrone)$name
}
# Gaussian impedance function
Gweight <- function(mintime, subzonetime, maxtime){
beta <- -((maxtime-mintime)^2)/log(0.01)
weight <- exp(-(subzonetime-mintime)^2/beta)
weight <- round(weight, 2)
return(weight)
}
# Create weights for catchment matrix
weight_NA <- 0
weight_10 <- Gweight(mintime = 5, subzonetime =  5, maxtime = 20)
weight_20 <- Gweight(mintime = 5, subzonetime = 15, maxtime = 20)
# Define names of subzones in catchment matrix
sub1 <- "0 to 10 mins"
sub2 <- "10 to 20 mins"
# Fill out weight matrix values
weight_matrix <- data.matrix(catchment_matrix, rownames.force = NA)
weight_matrix[is.na(weight_matrix)]   <- weight_NA
weight_matrix[weight_matrix == sub1]  <- weight_10
weight_matrix[weight_matrix == sub2]  <- weight_20
# Make sure all values in matrix are numeric
class(weight_matrix) <- "numeric"
# The order of zip codes must match the order in your matrix
population_vector <- t(demand$total_coun)
colnames(population_vector) <- demand$TRACTCE_x
rownames(population_vector) <- "Population"
# Create provider vector (i.e. weighted population for each provider)
provider_vector <- population_vector %*% t(weight_matrix)
# Display provider vector values
provider_vector %>%
kbl(caption = "Provider Vector",
align = "r",
format.args = list(big.mark = ",",
scientific = FALSE)) %>%
kable_minimal("hover") %>%
row_spec(0, font_size = 11)
# Create supply for provider (use 1 for example)
supply <- 1
# Create provider to population ratio (per 100,000 residents)
for(k in 1:ncol(provider_vector)){
if(provider_vector[1,k] != 0){
provider_vector[1,k] <- ((100000 * supply) / provider_vector[1,k])
}
}
# Spatial Access Index (SPAI)
SPAI_vector <- provider_vector %*% weight_matrix
# Format SPAI values and calculate Spatial Access Ratio (SPAR)
SPAI <- as.data.frame(t(SPAI_vector)) %>%
rename(SPAI = Population) %>%
rownames_to_column(var = "TRACTCE_x") %>%
mutate(SPAR = SPAI / mean(SPAI)) %>%
select(TRACTCE_x, SPAI, SPAR)
# Display first 10 values
SPAI[1:10,] %>%
kbl(caption = "Check SPAI and SPAR Values for 10 Tracts",
align = "r") %>%
kable_minimal("hover")
index_gdf <- st_read(dsn="/Users/akhil/Documents/Fire Vulnerability Project/index_gdf_with_distance/index_gdf_with_distance.shp")
# Create SPAI and SPAR values shapefile
SPAR_map <- left_join((index_gdf %>%
mutate(TRACTCE_x = as.character(TRACTCE_x))),
SPAI,
by = "TRACTCE_x")
# Define color palettes for map
spar_palette <- colorNumeric(palette = "viridis",
domain = SPAR_map$SPAR)
spai_palette <- colorNumeric(palette = "magma",
domain = SPAR_map$SPAI)
SPAR_map %>%
leaflet() %>%
addProviderTiles(provider = "CartoDB.Positron") %>%
# Add SPAR values
addPolygons(stroke = TRUE,
weight = 1,
color = "white",
smoothFactor = 0,
fillOpacity = 0.7,
fillColor = ~spar_palette(SPAR),
popup = paste0("<b>Census Tract: ",
SPAR_map$TRACTCE_x,
"</b><br>SPAR :",
round(SPAR_map$SPAR,2),
"<br>Total Count: ",
prettyNum(SPAR_map$total_coun,
big.mark = ",")),
group = "SPAR") %>%
# Add SPAI values
addPolygons(stroke = TRUE,
weight = 1,
color = "white",
smoothFactor = 0,
fillOpacity = 0.7,
fillColor = ~spai_palette(SPAI),
popup = paste0("<b>Census Tract: ",
SPAR_map$TRACTCE_x,
"</b><br>SPAI :",
round(SPAR_map$SPAI,2),
"<br>Total Count: ",
prettyNum(SPAR_map$total_coun,
big.mark = ",")),
group = "SPAI") %>%
# Add Pittsburgh UPMC hospital locations
addCircleMarkers(lng = hosp_supply$long,
lat = hosp_supply$lat,
radius = 5,
stroke = TRUE,
color = "black",
fillOpacity = .75,
fillColor = "red",
group = c("Hospitals")) %>%
# Add legends
addLegend("topright",
pal = spar_palette,
values = ~SPAR,
opacity = 1,
group = "SPAR") %>%
addLegend("topright",
pal = spai_palette,
values = ~SPAI,
opacity = 1,
group = "SPAI") %>%
# Add layers control (and default "SPAI" to off)
addLayersControl(position = "topleft",
options = layersControlOptions(collapsed = FALSE,
autoZIndex = FALSE),
baseGroups = c("SPAR","SPAI"),
overlayGroups = c("Hospitals")) %>%
hideGroup("SPAI")
st_write(SPAR_map, "/Users/akhil/Documents/Fire Vulnerability Project/2SFCA Analysis/Results/SPAR_map_HS_Inc.shp")
# Use pacman package to load packages used for exercise
library(pacman)
p_load(tidyverse,   # Variety of packages for data manipulation
sf,          # Variety of functions for manipulating spatial data
kableExtra,  # For creating tables
tidycensus,  # Package for downloading census data
RCurl,       # For composing general HTTP requests
rjson,       # Converts R objects to JSON objects and vice-versa
leaflet,     # For creating interactive maps
hereR,       # Package for accessing HERE isoline API
rgdal,       # Geospatial bindings (used for writing and reading .shp files)
sp,          # Spatial data package
profvis)     # Includes pause() function to slow down API calls
demand = read.csv("/Users/akhil/Documents/Fire Vulnerability Project/2SFCA Analysis/Census-Tracts.csv")
leaflet() %>%
addProviderTiles("CartoDB.Positron", group="Greyscale") %>%
addCircleMarkers(lng = demand$long,
lat = demand$lat,
radius = 0.5,
fillOpacity = .25,
)
demand.sf <- st_as_sf(x = demand,
coords = c("long", "lat"),
crs = "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0")
# Set HERE key
here_key <- ""
set_key(here_key)
# Create spatial polygons data frame
isochrone.sp <- as(isochrone, "Spatial")
# Save spatial polygons data frame as a shapefile in a folder called "Isochrones"
dsn <- paste0("/Users/akhil/Documents/Fire Vulnerability Project/2SFCA Analysis/data/Isochrones")
layer <- demand.sf$TRACTCE_x[i]
writeOGR(obj = isochrone.sp,
dsn = dsn,
layer = layer,
driver = "ESRI Shapefile")
# Add a 1 second pause to prevent overload
pause(1)
fire_supply <- read.csv("/Users/akhil/Documents/Fire Vulnerability Project/2SFCA Analysis/Fire-Stations.csv")
fire_supply.sf <- st_as_sf(x = fire_supply,
coords = c("long", "lat"),
crs = "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0")
# Convert to spatial points
fire_supply.sp <- as(fire_supply.sf, "Spatial")
# Create list of isochrones
isochrone_list <- "/Users/akhil/Documents/Fire Vulnerability Project/2SFCA Analysis/data/Isochrones"
shape.extension <- list.files(path = isochrone_list,
pattern = ".shp",
full.names = TRUE)
shape.names <- list.files(path = isochrone_list,
pattern = ".shp",
full.names = FALSE) %>%
str_remove(".shp")
catchment_matrix <- matrix(ncol = length(shape.names),
nrow = nrow(fire_supply.sp))
colnames(catchment_matrix) <- shape.names
rownames(catchment_matrix) <- fire_supply.sp$Location
# Fill out matrix
for(i in 1:length(shape.names)){
# Loads isochrone shapefile
isochrone <- readOGR(shape.extension[i])
# Matches projection with fire station points projection
isochrone@proj4string@projargs <- fire_supply.sp@proj4string@projargs
# Plots fire station points over catchment areas and takes name of subzone
catchment_matrix[,i] <- over(fire_supply.sp,
isochrone)$name
}
# Gaussian impedance function
Gweight <- function(mintime, subzonetime, maxtime){
beta <- -((maxtime-mintime)^2)/log(0.01)
weight <- exp(-(subzonetime-mintime)^2/beta)
weight <- round(weight, 2)
return(weight)
}
# Create weights for catchment matrix
weight_NA <- 0
weight_10 <- Gweight(mintime = 5, subzonetime =  5, maxtime = 20)
weight_20 <- Gweight(mintime = 5, subzonetime = 15, maxtime = 20)
# Define names of subzones in catchment matrix
sub1 <- "0 to 10 mins"
sub2 <- "10 to 20 mins"
# Fill out weight matrix values
weight_matrix <- data.matrix(catchment_matrix, rownames.force = NA)
weight_matrix[is.na(weight_matrix)]   <- weight_NA
weight_matrix[weight_matrix == sub1]  <- weight_10
weight_matrix[weight_matrix == sub2]  <- weight_20
# Make sure all values in matrix are numeric
class(weight_matrix) <- "numeric"
# The order of zip codes must match the order in your matrix
population_vector <- t(demand$TotalPopul)
colnames(population_vector) <- demand$TRACTCE_x
rownames(population_vector) <- "Population"
# Create provider vector (i.e. weighted population for each provider)
provider_vector <- population_vector %*% t(weight_matrix)
# Display provider vector values
provider_vector %>%
kbl(caption = "Provider Vector",
align = "r",
format.args = list(big.mark = ",",
scientific = FALSE)) %>%
kable_minimal("hover") %>%
row_spec(0, font_size = 11)
# Create supply for provider (use 1 for example)
supply <- 1
# Create provider to population ratio (per 100,000 residents)
for(k in 1:ncol(provider_vector)){
if(provider_vector[1,k] != 0){
provider_vector[1,k] <- ((100000 * supply) / provider_vector[1,k])
}
}
# Spatial Access Index (SPAI)
SPAI_vector <- provider_vector %*% weight_matrix
# Format SPAI values and calculate Spatial Access Ratio (SPAR)
SPAI <- as.data.frame(t(SPAI_vector)) %>%
rename(SPAI = Population) %>%
rownames_to_column(var = "TRACTCE_x") %>%
mutate(SPAR = SPAI / mean(SPAI)) %>%
select(TRACTCE_x, SPAI, SPAR)
# Display first 10 values
SPAI[1:10,] %>%
kbl(caption = "Check SPAI and SPAR Values for 10 Tracts",
align = "r") %>%
kable_minimal("hover")
index_gdf <- st_read(dsn="/Users/akhil/Documents/Fire Vulnerability Project/index_gdf_with_distance/index_gdf_with_distance.shp")
# Create SPAI and SPAR values shapefile
SPAR_map <- left_join((index_gdf %>%
mutate(TRACTCE_x = as.character(TRACTCE_x))),
SPAI,
by = "TRACTCE_x")
# Define color palettes for map
spar_palette <- colorNumeric(palette = "viridis",
domain = SPAR_map$SPAR)
spai_palette <- colorNumeric(palette = "magma",
domain = SPAR_map$SPAI)
SPAR_map %>%
leaflet() %>%
addProviderTiles(provider = "CartoDB.Positron") %>%
# Add SPAR values
addPolygons(stroke = TRUE,
weight = 1,
color = "white",
smoothFactor = 0,
fillOpacity = 0.7,
fillColor = ~spar_palette(SPAR),
popup = paste0("<b>ZIP Code: ",
SPAR_map$TRACTCE_x,
"</b><br>SPAR :",
round(SPAR_map$SPAR,2),
"<br>Total Count: ",
prettyNum(SPAR_map$TotalPopul,
big.mark = ",")),
group = "SPAR") %>%
# Add SPAI values
addPolygons(stroke = TRUE,
weight = 1,
color = "white",
smoothFactor = 0,
fillOpacity = 0.7,
fillColor = ~spai_palette(SPAI),
popup = paste0("<b>ZIP Code: ",
SPAR_map$TRACTCE_x,
"</b><br>SPAI :",
round(SPAR_map$SPAI,2),
"<br>Total Count: ",
prettyNum(SPAR_map$TotalPopul,
big.mark = ",")),
group = "SPAI") %>%
# Add Pittsburgh UPMC hospital locations
addCircleMarkers(lng = fire_supply$long,
lat = fire_supply$lat,
radius = 5,
stroke = TRUE,
color = "black",
fillOpacity = .75,
fillColor = "red",
group = c("Fire Stations")) %>%
# Add legends
addLegend("topright",
pal = spar_palette,
values = ~SPAR,
opacity = 1,
group = "SPAR") %>%
addLegend("topright",
pal = spai_palette,
values = ~SPAI,
opacity = 1,
group = "SPAI") %>%
# Add layers control (and default "SPAI" to off)
addLayersControl(position = "topleft",
options = layersControlOptions(collapsed = FALSE,
autoZIndex = FALSE),
baseGroups = c("SPAR","SPAI"),
overlayGroups = c("Fire Stations")) %>%
hideGroup("SPAI")
st_write(SPAR_map, "/Users/akhil/Documents/Fire Vulnerability Project/2SFCA Analysis/Results/SPAR_map_FS_Pop.shp")
# Use pacman package to load packages used for exercise
library(pacman)
p_load(tidyverse,   # Variety of packages for data manipulation
sf,          # Variety of functions for manipulating spatial data
kableExtra,  # For creating tables
tidycensus,  # Package for downloading census data
RCurl,       # For composing general HTTP requests
rjson,       # Converts R objects to JSON objects and vice-versa
leaflet,     # For creating interactive maps
hereR,       # Package for accessing HERE isoline API
rgdal,       # Geospatial bindings (used for writing and reading .shp files)
sp,          # Spatial data package
profvis)     # Includes pause() function to slow down API calls
demand = read.csv("/Users/akhil/Documents/Fire Vulnerability Project/2SFCA Analysis/Census-Tracts.csv")
leaflet() %>%
addProviderTiles("CartoDB.Positron", group="Greyscale") %>%
addCircleMarkers(lng = demand$long,
lat = demand$lat,
radius = 0.5,
fillOpacity = .25,
)
demand.sf <- st_as_sf(x = demand,
coords = c("long", "lat"),
crs = "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0")
# Set HERE key
here_key <- ""
set_key(here_key)
fire_supply <- read.csv("/Users/akhil/Documents/Fire Vulnerability Project/2SFCA Analysis/Fire-Stations.csv")
fire_supply.sf <- st_as_sf(x = fire_supply,
coords = c("long", "lat"),
crs = "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0")
# Convert to spatial points
fire_supply.sp <- as(fire_supply.sf, "Spatial")
# Create list of isochrones
isochrone_list <- "/Users/akhil/Documents/Fire Vulnerability Project/2SFCA Analysis/data/Isochrones"
shape.extension <- list.files(path = isochrone_list,
pattern = ".shp",
full.names = TRUE)
shape.names <- list.files(path = isochrone_list,
pattern = ".shp",
full.names = FALSE) %>%
str_remove(".shp")
catchment_matrix <- matrix(ncol = length(shape.names),
nrow = nrow(fire_supply.sp))
colnames(catchment_matrix) <- shape.names
rownames(catchment_matrix) <- fire_supply.sp$Location
# Fill out matrix
for(i in 1:length(shape.names)){
# Loads isochrone shapefile
isochrone <- readOGR(shape.extension[i])
# Matches projection with hospital points projection
isochrone@proj4string@projargs <- fire_supply.sp@proj4string@projargs
# Plots hospital points over catchment areas and takes name of subzone
catchment_matrix[,i] <- over(fire_supply.sp,
isochrone)$name
}
# Gaussian impedance function
Gweight <- function(mintime, subzonetime, maxtime){
beta <- -((maxtime-mintime)^2)/log(0.01)
weight <- exp(-(subzonetime-mintime)^2/beta)
weight <- round(weight, 2)
return(weight)
}
# Create weights for catchment matrix
weight_NA <- 0
weight_10 <- Gweight(mintime = 5, subzonetime =  5, maxtime = 20)
weight_20 <- Gweight(mintime = 5, subzonetime = 15, maxtime = 20)
# Define names of subzones in catchment matrix
sub1 <- "0 to 10 mins"
sub2 <- "10 to 20 mins"
# Fill out weight matrix values
weight_matrix <- data.matrix(catchment_matrix, rownames.force = NA)
weight_matrix[is.na(weight_matrix)]   <- weight_NA
weight_matrix[weight_matrix == sub1]  <- weight_10
weight_matrix[weight_matrix == sub2]  <- weight_20
# Make sure all values in matrix are numeric
class(weight_matrix) <- "numeric"
# The order of zip codes must match the order in your matrix
population_vector <- t(demand$total_coun)
colnames(population_vector) <- demand$TRACTCE_x
rownames(population_vector) <- "Population"
# Create provider vector (i.e. weighted population for each provider)
provider_vector <- population_vector %*% t(weight_matrix)
# Display provider vector values
provider_vector %>%
kbl(caption = "Provider Vector",
align = "r",
format.args = list(big.mark = ",",
scientific = FALSE)) %>%
kable_minimal("hover") %>%
row_spec(0, font_size = 11)
# Create supply for provider (use 1 for example)
supply <- 1
# Create provider to population ratio (per 100,000 residents)
for(k in 1:ncol(provider_vector)){
if(provider_vector[1,k] != 0){
provider_vector[1,k] <- ((100000 * supply) / provider_vector[1,k])
}
}
# Spatial Access Index (SPAI)
SPAI_vector <- provider_vector %*% weight_matrix
# Format SPAI values and calculate Spatial Access Ratio (SPAR)
SPAI <- as.data.frame(t(SPAI_vector)) %>%
rename(SPAI = Population) %>%
rownames_to_column(var = "TRACTCE_x") %>%
mutate(SPAR = SPAI / mean(SPAI)) %>%
select(TRACTCE_x, SPAI, SPAR)
# Display first 10 values
SPAI[1:10,] %>%
kbl(caption = "Check SPAI and SPAR Values for 10 Tracts",
align = "r") %>%
kable_minimal("hover")
index_gdf <- st_read(dsn="/Users/akhil/Documents/Fire Vulnerability Project/index_gdf_with_distance/index_gdf_with_distance.shp")
# Create SPAI and SPAR values shapefile
SPAR_map <- left_join((index_gdf %>%
mutate(TRACTCE_x = as.character(TRACTCE_x))),
SPAI,
by = "TRACTCE_x")
# Define color palettes for map
spar_palette <- colorNumeric(palette = "viridis",
domain = SPAR_map$SPAR)
spai_palette <- colorNumeric(palette = "magma",
domain = SPAR_map$SPAI)
SPAR_map %>%
leaflet() %>%
addProviderTiles(provider = "CartoDB.Positron") %>%
# Add SPAR values
addPolygons(stroke = TRUE,
weight = 1,
color = "white",
smoothFactor = 0,
fillOpacity = 0.7,
fillColor = ~spar_palette(SPAR),
popup = paste0("<b>ZIP Code: ",
SPAR_map$TRACTCE_x,
"</b><br>SPAR :",
round(SPAR_map$SPAR,2),
"<br>Total Count: ",
prettyNum(SPAR_map$total_coun,
big.mark = ",")),
group = "SPAR") %>%
# Add SPAI values
addPolygons(stroke = TRUE,
weight = 1,
color = "white",
smoothFactor = 0,
fillOpacity = 0.7,
fillColor = ~spai_palette(SPAI),
popup = paste0("<b>ZIP Code: ",
SPAR_map$TRACTCE_x,
"</b><br>SPAI :",
round(SPAR_map$SPAI,2),
"<br>Total Count: ",
prettyNum(SPAR_map$total_coun,
big.mark = ",")),
group = "SPAI") %>%
# Add Pittsburgh UPMC hospital locations
addCircleMarkers(lng = fire_supply$long,
lat = fire_supply$lat,
radius = 5,
stroke = TRUE,
color = "black",
fillOpacity = .75,
fillColor = "red",
group = c("Fire Stations")) %>%
# Add legends
addLegend("topright",
pal = spar_palette,
values = ~SPAR,
opacity = 1,
group = "SPAR") %>%
addLegend("topright",
pal = spai_palette,
values = ~SPAI,
opacity = 1,
group = "SPAI") %>%
# Add layers control (and default "SPAI" to off)
addLayersControl(position = "topleft",
options = layersControlOptions(collapsed = FALSE,
autoZIndex = FALSE),
baseGroups = c("SPAR","SPAI"),
overlayGroups = c("Fire Stations")) %>%
hideGroup("SPAI")
st_write(SPAR_map, "/Users/akhil/Documents/Fire Vulnerability Project/2SFCA Analysis/Results/SPAR_map_FS_Inc.shp")
